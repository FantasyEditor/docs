# 作弊
这些功能可以让你更简单的调试你的地图，对地图开发提供帮助。

### 重载
这些功能可以帮助你在游戏运行时重新加载某些脚本，使你可以在不用重启游戏的情况下快速查看修改结果。

#### include
加载脚本

这个函数的功能与`require`相同。在开发环境中，当你使用[reload]进行重载时，使用该函数加载的脚本会被重新读取并加载。如果重新加载的脚本是技能定义等没有局部状态的脚本，一般不会有什么问题。但如果加载的脚本中你创建了一些对象或是修改了一些状态，那么重新加载脚本后可能会再次创建出这些对象或是被状态影响。如果想实现比较完善的重载功能，你需要和[on_reload]以及[is_reloading]配合。

无论如何，重载都不是一个安全的行为。如果有些功能难以重载，那么就老老实实的重新开始游戏吧。

!> 在正式环境中该函数等价于于`require`，没有重载的功能。

#### on_reload
重载事件

* 参数
    * *start* (function) - 重载开始事件
    * *finish* (function) - 重载结束事件

当使用[reload]进行重载脚本时会触发此事件。你可以使用这个方法注册2个事件，分别在重载开始于重载结束时触发。利用重载开始事件，你可以在重载开始时移除脚本中创建的各种对象，避免重载脚本后重复注册。利用重载结束事件，你可以在重载结束时对脚本的环境进行一些初始化或还原。

```lua
    ac.cheat.on_reload(function ()
        -- 重载开始的处理代码
    end, function ()
        -- 重载结束的处理代码
    end)
```

#### is_reloading
是否正在重载

* 返回
    * result (boolean) - 是否正在重载

重载脚本时会重新执行一次脚本代码，有时你需要根据当前是不是因为重载而执行代码进行差异化处理。使用这个函数可以进行区分。

```lua
    if ac.cheat.is_reloading() then
        -- 重载时的差异处理
    else
        -- 正常加载时的处理
    end
```

#### reload
重载

重载所有使用[include]加载的脚本，加载顺序与[include]的顺序相同。重载的流程如下：

1. 重载开始：
    触发[on_reload]的重载开始事件。
2. 重新加载脚本：
    所有使用[include]加载的脚本会依次重新读取并加载。在重载过程中，每个文件智慧被加载一次。当重载的脚本中包含[技能构造]与[状态构造]时，之前定义的技能或状态定义会被清空，一遍你重新添加方法与属性。
3. 重载所有玩家的[英雄]，对每个英雄执行：
    1. 移除英雄的所有技能与状态
    2. 回满英雄的[生命]与[魔法]
    3. 将[HeroSkill]中定义的技能依次添加到[英雄技能槽]中。
    4. 将[HideSkill]中定义的技能依次添加到[隐藏技能槽]中。
    5. 以英雄为对象，触发[单位-重载]事件。
4. 重载结束
    触发[on_reload]的重载结束事件。

```lua
    ac.cheat.reload()
```

!> 该功能在正式环境中不可用

### 作弊功能
待补充

[reload]: ac/api/cheat?=reload
[on_reload]: ac/api/cheat?=on_reload
[is_reloading]: ac/api/cheat?=is_reloading
[技能构造]: ac/api/skill?=构造
[状态构造]: ac/api/buff?=构造
[生命]: ac/unit/attribute?=生命
[魔法]: ac/unit/attribute?=魔法
[英雄]: ac/term/英雄
[HeroSkill]: 404
[HideSkill]: 404
[英雄技能槽]: ac/term/技能槽?=英雄
[隐藏技能槽]: ac/term/技能槽?=隐藏
[单位-重载]: 404
